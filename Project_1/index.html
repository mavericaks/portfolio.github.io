<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project 1 - Design and Analysis of Algorithms</title>
<link rel="stylesheet" href="styles.css">

</head>
<body>
    <header>
        <h1>Project 1: Structured Enquiry of Design and Analysis of Algorithms</h1>
     <p>This project aims to demonstrate the key concepts I have learned, 
         along with the major challenges encountered during the process.
         It explores how these challenges are linked to real-world applications and 
         how I applied the most efficient approaches to solve complex problems in each area of enquiry.</p>

    </header>
    <main>
        <section>
            <h2>Key Concepts Covered:</h2>
            <ul>
                <li>Time Complexity Analysis</li>
                <li>Binary Search Tree</li>
                <li>DFS and BFS</li>
                <li>Heap</li>
                <li>Sorting</li>
                <li>Pattern Searching</li>
                <li>Graph Algorithms</li>
            </ul>
        </section>
    </main>
    <main>
        <section>
            <h2>Reflection on Key Concepts</h2>

            <h3>1. Time Complexity Analysis</h3>
            <p><strong>Challenges in learning/understanding:</strong></p>
            <ul>
                <li>Grasping how time complexity affects algorithm performance, especially for nested loops and recursion.</li>
                <li>Understanding the nuances of Big-O, Big-Theta, and Big-Omega notations.</li>
            </ul>
            <p><strong>Challenges in correlating with real-world applications:</strong></p>
            <ul>
                <li>Applying theoretical complexity analysis to real-world scenarios where inputs are dynamic or unpredictable.</li>
                <li>Estimating worst-case vs. average-case performance in practical settings.</li>
            </ul>
            <p><strong>How to determine the most efficient approach/design techniques:</strong></p>
            <ul>
                <li>Compare algorithms using their time complexity for the given constraints.</li>
                <li>Test algorithms on varying input sizes to validate theoretical analysis.</li>
            </ul>

            <h3>2. Binary Search Tree (BST)</h3>
            <p><strong>Challenges in learning/understanding:</strong></p>
            <ul>
                <li>Understanding tree traversal methods like in-order, pre-order, and post-order.</li>
                <li>Dealing with edge cases such as duplicate elements and imbalanced trees.</li>
            </ul>
            <p><strong>Challenges in correlating with real-world applications:</strong></p>
            <ul>
                <li>Adapting BSTs for dynamic datasets, like in databases or file systems.</li>
                <li>Implementing operations like insertion, deletion, and search in real-time systems.</li>
            </ul>
            <p><strong>How to determine the most efficient approach/design techniques:</strong></p>
            <ul>
                <li>Ensure the tree remains balanced (e.g., use AVL or Red-Black trees).</li>
                <li>Optimize traversal based on the frequency of access to specific nodes.</li>
            </ul>

            <h3>3. DFS and BFS</h3>
            <p><strong>Challenges in learning/understanding:</strong></p>
            <ul>
                <li>Visualizing the traversal process for complex graphs with cycles.</li>
                <li>Implementing DFS and BFS with appropriate data structures (e.g., stack for DFS, queue for BFS).</li>
            </ul>
            <p><strong>Challenges in correlating with real-world applications:</strong></p>
            <ul>
                <li>Applying BFS for shortest-path problems and DFS for pathfinding in graphs.</li>
                <li>Handling memory constraints in BFS for large graphs.</li>
            </ul>
            <p><strong>How to determine the most efficient approach/design techniques:</strong></p>
            <ul>
                <li>Use BFS for scenarios requiring level-order exploration (e.g., social networks).</li>
                <li>Use DFS for scenarios requiring exhaustive exploration (e.g., puzzle-solving).</li>
            </ul>

            <h3>4. Heap</h3>
            <p><strong>Challenges in learning/understanding:</strong></p>
            <ul>
                <li>Understanding how heaps are structured and maintained during insertion and deletion.</li>
                <li>Differentiating between min-heaps and max-heaps and their applications.</li>
            </ul>
            <p><strong>Challenges in correlating with real-world applications:</strong></p>
            <ul>
                <li>Using heaps in priority queues for task scheduling or resource allocation.</li>
                <li>Implementing heaps for real-time applications where performance is critical.</li>
            </ul>
            <p><strong>How to determine the most efficient approach/design techniques:</strong></p>
            <ul>
                <li>Use binary heaps for simplicity and Fibonacci heaps for better amortized time complexity in specific cases.</li>
                <li>Optimize heapify operations for large datasets.</li>
            </ul>

            <h3>5. Sorting</h3>
            <p><strong>Challenges in learning/understanding:</strong></p>
            <ul>
                <li>Differentiating between various sorting algorithms (e.g., quicksort, mergesort, bubblesort) and their use cases.</li>
                <li>Understanding in-place sorting vs. external sorting for memory-constrained environments.</li>
            </ul>
            <p><strong>Challenges in correlating with real-world applications:</strong></p>
            <ul>
                <li>Applying sorting in database queries, file systems, and search engines.</li>
                <li>Balancing time complexity with stability requirements for specific use cases.</li>
            </ul>
            <p><strong>How to determine the most efficient approach/design techniques:</strong></p>
            <ul>
                <li>Use quicksort for average-case performance, mergesort for stability, and heapsort for memory efficiency.</li>
                <li>Consider parallel sorting techniques for very large datasets.</li>
            </ul>

            <h3>6. Pattern Searching</h3>
            <p><strong>Challenges in learning/understanding:</strong></p>
            <ul>
                <li>Understanding different algorithms like KMP, Rabin-Karp, and their complexity.</li>
                <li>Dealing with overlapping patterns and large text datasets.</li>
            </ul>
            <p><strong>Challenges in correlating with real-world applications:</strong></p>
            <ul>
                <li>Applying pattern searching in text editors, search engines, and bioinformatics.</li>
                <li>Handling noisy data or approximate matches in real-world text processing.</li>
            </ul>
            <p><strong>How to determine the most efficient approach/design techniques:</strong></p>
            <ul>
                <li>Use KMP for deterministic patterns and Rabin-Karp for multiple pattern searching.</li>
                <li>Optimize algorithms for pre-processing and indexing large datasets.</li>
            </ul>

            <h3>7. Graph Algorithms</h3>
            <p><strong>Challenges in learning/understanding:</strong></p>
            <ul>
                <li>Grasping concepts like graph representation (adjacency matrix vs. adjacency list).</li>
                <li>Understanding advanced graph algorithms like Dijkstra’s, Prim’s, and Kruskal’s.</li>
            </ul>
            <p><strong>Challenges in correlating with real-world applications:</strong></p>
            <ul>
                <li>Applying graph algorithms in fields like network optimization, supply chain logistics, and AI pathfinding.</li>
                <li>Balancing accuracy and performance for large graphs in real-time applications.</li>
            </ul>
            <p><strong>How to determine the most efficient approach/design techniques:</strong></p>
            <ul>
                <li>Use adjacency lists for sparse graphs and adjacency matrices for dense graphs.</li>
                <li>Optimize algorithms with heuristics for specific applications (e.g., A* for pathfinding).</li>
            </ul>
        </section>
    </main>
</body>
</html>
